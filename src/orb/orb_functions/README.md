![Occupant Responsive Buildlings](../Documentation/assets/orb_title.png)

# Algorithm Explanation

The API takes an optimization approach to determining the best start and end times for a given day—

Each day’s wifi connection time series can be treated as a step function, hereafter referred to as <img src="https://render.githubusercontent.com/render/math?math=f(x)">. Assuming that connection count is polled at n regular intervals, this series can be divided into <img src="https://render.githubusercontent.com/render/math?math=\frac{n(n-1)}{2}"> segments with distinct start time index <img src="https://render.githubusercontent.com/render/math?math=a"> and end time index <img src="https://render.githubusercontent.com/render/math?math=b">, per the triangular number formula. At the standard 5-minute intervals used for polling wifi connection data, there are 41,328 such segments of the day.

Each of these segments cover a portion of the day’s total wifi connections, represented as <img src="https://render.githubusercontent.com/render/math?math=\frac{ \sum_{a}^{b} f(x) }{ \sum f(x) }">, a quantity we must maximize to ensure we’re identifying a segment of the day that covers as many connected devices as possible. Each segment also covers a portion of the day’s total time, represented as <img src="https://render.githubusercontent.com/render/math?math=\frac{b-a}{n}">, which we minimize to prevent unnecessary resource allocation. In order to optimize both of these proportions in their respective directions, we maximize their quotient. However, when done naively, this tends to identify a very short segment where the peak number of wifi connections occurred on that day, unfortunately missing many of the day’s connections. To address this, we set a threshold ε, the minimum proportion of wifi connections that must be captured by the segment, which is set to 0.9 by default but is customizable within the API call. This renders the optimizing function as follows:

<img src="https://render.githubusercontent.com/render/math?math=max \left( \frac{ \frac{ \sum_{a}^{b} f(x) }{ \sum f(x) }}{ \frac{ b-a }{ n }} \right); \frac{ \sum_{a}^{b} f(x) }{ \sum f(x) } > \varepsilon">

From a programmatic efficiency perspective, we benefit from a relatively small overall state space of 41,328 segments. As such, we are able to exhaustively search the space by calculating all possible ratios of ratios described above. That said, this is a <img src="https://render.githubusercontent.com/render/math?math=O(n^2)"> approach and would require significantly more resources if the intervals are shorter than 5 minutes or if multiple days are analyzed through this approach in aggregate. To use the brute-force approach in this situation and/or while working with limited computing resources, one may have to set bounds on <img src="https://render.githubusercontent.com/render/math?math=a"> and <img src="https://render.githubusercontent.com/render/math?math=b"> to reduce the number of segments being considered or condense the data into fewer intervals, potentially by averaging, summing, or picking one set value from a set of multiple intervals being aggregated. Alternatively, one can utilize a gradient ascent-like approach to exploring the state space, beginning training at the current start and end times used by the building for scheduling and calculating the ratios for surrounding segments to find the path to the optimal maximum—however, we have no guarantees this will converge at an optimal point given the expected variability in the data.

In order to suggest optimal start and end times for a given day of the week, we run the algorithm on specific dates that fell on that day of the week and collect the output start and end times. Thereafter, we select the suggested start time at the <img src="https://render.githubusercontent.com/render/math?math=( 1 - \vartheta )"><sup>th</sup> percentile in its series and the suggested end time at the <img src="https://render.githubusercontent.com/render/math?math=\vartheta"><sup>th</sup> percentile in its series, where <img src="https://render.githubusercontent.com/render/math?math=\vartheta"> is a customizable threshold defaulting to 0.9, in order to represent the best times for that day of the week. This removes the <img src="https://render.githubusercontent.com/render/math?math=( 1 - \vartheta )"> proportion of outlier results that may appear, such as holidays and other abnormal differences in occupancy.
